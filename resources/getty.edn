{:rendering-engine :google/incremental-dom
 :version [0 0 1]
 :state {:failed false}
 ;;; TODO: Still need a way to specify which database resources
 ;;; are involved...though they don't belong in this
 ;;; script. They're really part of the App
 ;;; installation process
 ;;; And a list of privilege requirements
 ;;; For that matter...surely some of this makes sense at the "client" level...doesn't it?
 ;;; (well, maybe not for something this simple. But more generally)

 ;; This is the code that actually runs in the browser's Web Worker.
 ;; Really need to be able to specify library dependencies
 ;; But this approach seems like a reasonable start.
 :render-code [(defn random-rejection []
                 "Your father was a hamster and your mother smelled of elder berries")
               ;; on-render will get called once with the current world state
               ;; as its param. It should return a list of function calls
               ;; for the rendering engine to run.
               ;; TODO: Need to specify what these calls actually do
               ;; (it will eventually be a thin lispified wrapper over google's
               ;; incremental-dom library)
               ;; Note that this looks like a clojurescript function
               ;; with access to functions from the rendering engine and
               ;; the state, but...well, is it?
               ;; Or is it actually a DSL to provide another layer of
               ;; protection?
               (defn on-render [_]
                 `[(element-open :form)
                   (element-void :input "user-id" {:id "user-id"
                                                   :placeholder "Name"})
                   (element-void :input "password" {:id "password"
                                                    :placeholder "Password"})
                   ;; Note that this really can't be a macro, since this part
                   ;; absolutely must happen at runtime
                   ~@(when (:failed state)
                       `[(element-open :p)
                         (text ~(random-rejection))
                         (element-close :p)])
                   (element-open :button "login-submit")
                   (text "Submit")
                   (element-close :button)
                   (element-close :form)])
               (defn hash [password]
                 ;; FIXME: This absolutely must be run through a 1-way hash
                 ;; It seems like that process really should include a salt.
                 ;; Or is best practice to just send the password to the server
                 ;; and trust in TLS?
                 password)]
 ;; Put the browser-level event handlers here
 ;; Note that we still need proxies to connect
 ;; to the "real" virtual DOM to keep these
 ;; isolated in their Web Worker
 :render-events [{:element "login-submit"
                  :events :click
                  ;; The values stored in these DOM elements will be extracted
                  ;; and passed to the handler when the event happens
                  :dependencies ["user-id" "password"]
                  ;; Although, really, it should just be receiving a) the "full" world
                  ;; state...which happens to be the DOM and b) the event.
                  ;; This needs/deserves more thought
                  :handler (fn [{:keys [user-id password]}]
                             ;; This is really a break from the Functional I/O
                             ;; paper. There's a question about how big a break,
                             ;; and how much less understandable this version
                             ;; might be.
                             ;; Go with this approach for now if only because it
                             ;; seems more obvious at the moment.
                             ;; Get it working first, then worry about getting it
                             ;; to work well.
                             ;; Rather than causing side-effects internally
                             ;; (which *is* legal inside a Web Worker and
                             ;; could happen anyway), event handlers should
                             ;; return the message they want to post
                             ;; Actually, this pattern seems so common and
                             ;; obvious that I doubtlessly want a wrapper to
                             ;; just specify it
                             {:message :login/credentials
                              :params {:user-id user-id
                                       :password (hash password)}})}

                 {;; If there's no :element key, add this event to the dispatcher
                  ;; in the onmessage() handler
                  :login/succeeded (fn [event]
                                     (let [success (:success event)]
                                       (swap! state #(assoc % :failed (not success)))
                                       (when success
                                         ;; Just a wrapper around js/close
                                         (close!))))}]

 ;;; "universe"-code that runs on the
 ;;; server.
 ;;; Client events map to the event handlers specified here
 :universe-events {:login/credentials (fn [{:keys [user password]}]
                                        ;; For now, just keep this dead simple:
                                        ;; any credentials get access
                                        {:login/suceeded
                                         (if (and (< 0 (count user))
                                                  (< 0 (count password)))
                                           (do
                                             ;; Note that the ability to do this implies special
                                             ;; privileges
                                             (fork! :shell)
                                             {:success true})
                                           {:success false
                                            :explanation "C'mon...gimme somethin'!"})})
                   }
 }
